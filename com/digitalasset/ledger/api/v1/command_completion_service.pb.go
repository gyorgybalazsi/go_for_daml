// Code generated by protoc-gen-go. DO NOT EDIT.
// source: com/digitalasset/ledger/api/v1/command_completion_service.proto

package com_digitalasset_ledger_api_v1

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protobuf "google/protobuf"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type CompletionStreamRequest struct {
	// Must correspond to the ledger id reported by the Ledger Identification Service.
	// Required
	LedgerId string `protobuf:"bytes,1,opt,name=ledger_id,json=ledgerId,proto3" json:"ledger_id,omitempty"`
	// Only completions of commands submitted with the same application_id will be visible in the stream.
	// Required
	ApplicationId string `protobuf:"bytes,2,opt,name=application_id,json=applicationId,proto3" json:"application_id,omitempty"`
	// Non-empty list of parties whose data should be included.
	// Required
	Parties []string `protobuf:"bytes,3,rep,name=parties,proto3" json:"parties,omitempty"`
	// This field indicates the minimum offset for completions. This can be used to resume an earlier completion stream.
	// Optional, if not set the ledger uses the current ledger end offset instead.
	Offset               *LedgerOffset `protobuf:"bytes,4,opt,name=offset,proto3" json:"offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *CompletionStreamRequest) Reset()         { *m = CompletionStreamRequest{} }
func (m *CompletionStreamRequest) String() string { return proto.CompactTextString(m) }
func (*CompletionStreamRequest) ProtoMessage()    {}
func (*CompletionStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8f528b21bb92044, []int{0}
}

func (m *CompletionStreamRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CompletionStreamRequest.Unmarshal(m, b)
}
func (m *CompletionStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CompletionStreamRequest.Marshal(b, m, deterministic)
}
func (m *CompletionStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompletionStreamRequest.Merge(m, src)
}
func (m *CompletionStreamRequest) XXX_Size() int {
	return xxx_messageInfo_CompletionStreamRequest.Size(m)
}
func (m *CompletionStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CompletionStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CompletionStreamRequest proto.InternalMessageInfo

func (m *CompletionStreamRequest) GetLedgerId() string {
	if m != nil {
		return m.LedgerId
	}
	return ""
}

func (m *CompletionStreamRequest) GetApplicationId() string {
	if m != nil {
		return m.ApplicationId
	}
	return ""
}

func (m *CompletionStreamRequest) GetParties() []string {
	if m != nil {
		return m.Parties
	}
	return nil
}

func (m *CompletionStreamRequest) GetOffset() *LedgerOffset {
	if m != nil {
		return m.Offset
	}
	return nil
}

type CompletionStreamResponse struct {
	// This checkpoint may be used to restart consumption.  The
	// checkpoint is after any completions in this response.
	// Optional
	Checkpoint *Checkpoint `protobuf:"bytes,1,opt,name=checkpoint,proto3" json:"checkpoint,omitempty"`
	// If set, one or more completions.
	Completions          []*Completion `protobuf:"bytes,2,rep,name=completions,proto3" json:"completions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *CompletionStreamResponse) Reset()         { *m = CompletionStreamResponse{} }
func (m *CompletionStreamResponse) String() string { return proto.CompactTextString(m) }
func (*CompletionStreamResponse) ProtoMessage()    {}
func (*CompletionStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8f528b21bb92044, []int{1}
}

func (m *CompletionStreamResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CompletionStreamResponse.Unmarshal(m, b)
}
func (m *CompletionStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CompletionStreamResponse.Marshal(b, m, deterministic)
}
func (m *CompletionStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompletionStreamResponse.Merge(m, src)
}
func (m *CompletionStreamResponse) XXX_Size() int {
	return xxx_messageInfo_CompletionStreamResponse.Size(m)
}
func (m *CompletionStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CompletionStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CompletionStreamResponse proto.InternalMessageInfo

func (m *CompletionStreamResponse) GetCheckpoint() *Checkpoint {
	if m != nil {
		return m.Checkpoint
	}
	return nil
}

func (m *CompletionStreamResponse) GetCompletions() []*Completion {
	if m != nil {
		return m.Completions
	}
	return nil
}

// Checkpoints may be used to:
//
// * detect time out of commands.
// * provide an offset which can be used to restart consumption.
type Checkpoint struct {
	// All commands with a maximum record time below this value MUST be considered lost if their completion has not arrived before this checkpoint.
	// Required
	RecordTime *protobuf.Timestamp `protobuf:"bytes,1,opt,name=record_time,json=recordTime,proto3" json:"record_time,omitempty"`
	// May be used in a subsequent CompletionStreamRequest to resume the consumption of this stream at a later time.
	// Required
	Offset               *LedgerOffset `protobuf:"bytes,2,opt,name=offset,proto3" json:"offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Checkpoint) Reset()         { *m = Checkpoint{} }
func (m *Checkpoint) String() string { return proto.CompactTextString(m) }
func (*Checkpoint) ProtoMessage()    {}
func (*Checkpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8f528b21bb92044, []int{2}
}

func (m *Checkpoint) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Checkpoint.Unmarshal(m, b)
}
func (m *Checkpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Checkpoint.Marshal(b, m, deterministic)
}
func (m *Checkpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Checkpoint.Merge(m, src)
}
func (m *Checkpoint) XXX_Size() int {
	return xxx_messageInfo_Checkpoint.Size(m)
}
func (m *Checkpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_Checkpoint.DiscardUnknown(m)
}

var xxx_messageInfo_Checkpoint proto.InternalMessageInfo

func (m *Checkpoint) GetRecordTime() *protobuf.Timestamp {
	if m != nil {
		return m.RecordTime
	}
	return nil
}

func (m *Checkpoint) GetOffset() *LedgerOffset {
	if m != nil {
		return m.Offset
	}
	return nil
}

type CompletionEndRequest struct {
	// Must correspond to the ledger ID reported by the Ledger Identification Service.
	// Required
	LedgerId string `protobuf:"bytes,1,opt,name=ledger_id,json=ledgerId,proto3" json:"ledger_id,omitempty"`
	// Server side tracing will be registered as a child of the submitted context.
	// This field is a future extension point and is currently not supported.
	// Optional
	TraceContext         *TraceContext `protobuf:"bytes,1000,opt,name=trace_context,json=traceContext,proto3" json:"trace_context,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *CompletionEndRequest) Reset()         { *m = CompletionEndRequest{} }
func (m *CompletionEndRequest) String() string { return proto.CompactTextString(m) }
func (*CompletionEndRequest) ProtoMessage()    {}
func (*CompletionEndRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8f528b21bb92044, []int{3}
}

func (m *CompletionEndRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CompletionEndRequest.Unmarshal(m, b)
}
func (m *CompletionEndRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CompletionEndRequest.Marshal(b, m, deterministic)
}
func (m *CompletionEndRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompletionEndRequest.Merge(m, src)
}
func (m *CompletionEndRequest) XXX_Size() int {
	return xxx_messageInfo_CompletionEndRequest.Size(m)
}
func (m *CompletionEndRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CompletionEndRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CompletionEndRequest proto.InternalMessageInfo

func (m *CompletionEndRequest) GetLedgerId() string {
	if m != nil {
		return m.LedgerId
	}
	return ""
}

func (m *CompletionEndRequest) GetTraceContext() *TraceContext {
	if m != nil {
		return m.TraceContext
	}
	return nil
}

type CompletionEndResponse struct {
	// This offset can be used in a CompletionStreamRequest message.
	// Required
	Offset               *LedgerOffset `protobuf:"bytes,1,opt,name=offset,proto3" json:"offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *CompletionEndResponse) Reset()         { *m = CompletionEndResponse{} }
func (m *CompletionEndResponse) String() string { return proto.CompactTextString(m) }
func (*CompletionEndResponse) ProtoMessage()    {}
func (*CompletionEndResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8f528b21bb92044, []int{4}
}

func (m *CompletionEndResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CompletionEndResponse.Unmarshal(m, b)
}
func (m *CompletionEndResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CompletionEndResponse.Marshal(b, m, deterministic)
}
func (m *CompletionEndResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompletionEndResponse.Merge(m, src)
}
func (m *CompletionEndResponse) XXX_Size() int {
	return xxx_messageInfo_CompletionEndResponse.Size(m)
}
func (m *CompletionEndResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CompletionEndResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CompletionEndResponse proto.InternalMessageInfo

func (m *CompletionEndResponse) GetOffset() *LedgerOffset {
	if m != nil {
		return m.Offset
	}
	return nil
}

func init() {
	proto.RegisterType((*CompletionStreamRequest)(nil), "com.digitalasset.ledger.api.v1.CompletionStreamRequest")
	proto.RegisterType((*CompletionStreamResponse)(nil), "com.digitalasset.ledger.api.v1.CompletionStreamResponse")
	proto.RegisterType((*Checkpoint)(nil), "com.digitalasset.ledger.api.v1.Checkpoint")
	proto.RegisterType((*CompletionEndRequest)(nil), "com.digitalasset.ledger.api.v1.CompletionEndRequest")
	proto.RegisterType((*CompletionEndResponse)(nil), "com.digitalasset.ledger.api.v1.CompletionEndResponse")
}

func init() {
	proto.RegisterFile("com/digitalasset/ledger/api/v1/command_completion_service.proto", fileDescriptor_d8f528b21bb92044)
}

var fileDescriptor_d8f528b21bb92044 = []byte{
	// 493 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x94, 0x41, 0x8b, 0xd3, 0x40,
	0x14, 0xc7, 0x99, 0x56, 0x76, 0xed, 0xab, 0x15, 0x19, 0x14, 0x43, 0x04, 0x2d, 0x01, 0xa1, 0x88,
	0x4c, 0xdc, 0xaa, 0x28, 0x78, 0x10, 0xb6, 0xeb, 0x61, 0x65, 0x61, 0x21, 0xee, 0x55, 0xc2, 0xec,
	0xe4, 0xb5, 0x0e, 0x26, 0x99, 0x31, 0x33, 0x2d, 0x1e, 0xbc, 0xef, 0xd1, 0xef, 0xe0, 0x67, 0xf0,
	0xea, 0xf7, 0xf1, 0x63, 0x48, 0x32, 0x69, 0x93, 0xae, 0x68, 0xb3, 0x7a, 0x7c, 0xc3, 0xfc, 0xde,
	0xfb, 0xbf, 0xf7, 0x7f, 0x33, 0xf0, 0x5a, 0xa8, 0x2c, 0x4c, 0xe4, 0x42, 0x5a, 0x9e, 0x72, 0x63,
	0xd0, 0x86, 0x29, 0x26, 0x0b, 0x2c, 0x42, 0xae, 0x65, 0xb8, 0x3a, 0x08, 0x85, 0xca, 0x32, 0x9e,
	0x27, 0xb1, 0x50, 0x99, 0x4e, 0xd1, 0x4a, 0x95, 0xc7, 0x06, 0x8b, 0x95, 0x14, 0xc8, 0x74, 0xa1,
	0xac, 0xa2, 0xf7, 0x85, 0xca, 0x58, 0x3b, 0x01, 0x73, 0x09, 0x18, 0xd7, 0x92, 0xad, 0x0e, 0xfc,
	0x70, 0x77, 0x81, 0x3a, 0xb1, 0x4b, 0xe8, 0x4f, 0x77, 0x00, 0x2e, 0x8a, 0xd5, 0x7c, 0x5e, 0x16,
	0xeb, 0xc6, 0xd8, 0x82, 0x0b, 0x8c, 0x85, 0xca, 0x2d, 0x7e, 0x5e, 0x33, 0x0f, 0x16, 0x4a, 0x2d,
	0x52, 0x0c, 0xab, 0xe8, 0x7c, 0x39, 0x0f, 0xad, 0xcc, 0xd0, 0x58, 0x9e, 0x69, 0x77, 0x21, 0xf8,
	0x41, 0xe0, 0xee, 0x6c, 0xa3, 0xee, 0x9d, 0x2d, 0x90, 0x67, 0x11, 0x7e, 0x5a, 0xa2, 0xb1, 0xf4,
	0x1e, 0x0c, 0x6a, 0x1d, 0x32, 0xf1, 0xc8, 0x98, 0x4c, 0x06, 0xd1, 0x75, 0x77, 0x70, 0x9c, 0xd0,
	0x87, 0x70, 0x93, 0x6b, 0x9d, 0x4a, 0xc1, 0xab, 0x79, 0xc9, 0xc4, 0xeb, 0x55, 0x37, 0x46, 0xad,
	0xd3, 0xe3, 0x84, 0x7a, 0xb0, 0xaf, 0x79, 0x61, 0x25, 0x1a, 0xaf, 0x3f, 0xee, 0x4f, 0x06, 0xd1,
	0x3a, 0xa4, 0x47, 0xb0, 0xe7, 0xda, 0xf3, 0xae, 0x8d, 0xc9, 0x64, 0x38, 0x7d, 0xcc, 0xfe, 0x3e,
	0x64, 0x76, 0x52, 0x45, 0xa7, 0x15, 0x13, 0xd5, 0x6c, 0xf0, 0x9d, 0x80, 0xf7, 0xbb, 0x7e, 0xa3,
	0x55, 0x6e, 0x90, 0xbe, 0x05, 0x10, 0x1f, 0x50, 0x7c, 0xd4, 0x4a, 0xe6, 0xb6, 0xea, 0x60, 0x38,
	0x7d, 0xb4, 0xab, 0xcc, 0x6c, 0x43, 0x44, 0x2d, 0x9a, 0x9e, 0xc0, 0xb0, 0x71, 0xd1, 0x78, 0xbd,
	0x71, 0xbf, 0x53, 0xb2, 0x0d, 0x12, 0xb5, 0xf1, 0xe0, 0x2b, 0x01, 0x68, 0x0a, 0xd1, 0x57, 0x30,
	0x2c, 0x50, 0xa8, 0x22, 0x89, 0x4b, 0x7f, 0x6a, 0xa5, 0x3e, 0x73, 0xe6, 0xb1, 0xb5, 0x79, 0xec,
	0x6c, 0x6d, 0x5e, 0x04, 0xee, 0x7a, 0x79, 0xd0, 0x1a, 0x64, 0xef, 0x3f, 0x06, 0x79, 0x41, 0xe0,
	0x76, 0xa3, 0xf6, 0x4d, 0x9e, 0x74, 0xda, 0x82, 0x08, 0x46, 0x5b, 0x6b, 0xe7, 0xfd, 0xdc, 0xef,
	0xa6, 0xe1, 0xac, 0xa4, 0x66, 0x0e, 0x8a, 0x6e, 0xd8, 0x56, 0x14, 0xbc, 0x87, 0x3b, 0x97, 0x84,
	0xd4, 0x76, 0x36, 0x8d, 0x92, 0x7f, 0x6f, 0x74, 0xfa, 0xad, 0x57, 0x6d, 0x4c, 0xf9, 0xe0, 0x5b,
	0x8b, 0xe3, 0x9e, 0x3b, 0xbd, 0x20, 0x70, 0xeb, 0xf2, 0x3a, 0xd1, 0x17, 0xdd, 0x5d, 0xde, 0x7a,
	0x40, 0xfe, 0xcb, 0xab, 0x83, 0xae, 0xd5, 0x27, 0x84, 0x7e, 0x81, 0xd1, 0xd6, 0x14, 0xe8, 0xb3,
	0xee, 0xc9, 0x1a, 0xf7, 0xfc, 0xe7, 0x57, 0xa4, 0x5c, 0xfd, 0xc3, 0x23, 0xd8, 0xf1, 0xe5, 0x1d,
	0x06, 0x7f, 0x9a, 0xe1, 0xe9, 0xd2, 0x62, 0x31, 0x2b, 0x99, 0xf3, 0xbd, 0x6a, 0x73, 0x9f, 0xfe,
	0x0a, 0x00, 0x00, 0xff, 0xff, 0x31, 0x66, 0x01, 0xa9, 0x80, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CommandCompletionServiceClient is the client API for CommandCompletionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CommandCompletionServiceClient interface {
	// Subscribe to command completion events.
	CompletionStream(ctx context.Context, in *CompletionStreamRequest, opts ...grpc.CallOption) (CommandCompletionService_CompletionStreamClient, error)
	// Returns the offset after the latest completion.
	CompletionEnd(ctx context.Context, in *CompletionEndRequest, opts ...grpc.CallOption) (*CompletionEndResponse, error)
}

type commandCompletionServiceClient struct {
	cc *grpc.ClientConn
}

func NewCommandCompletionServiceClient(cc *grpc.ClientConn) CommandCompletionServiceClient {
	return &commandCompletionServiceClient{cc}
}

func (c *commandCompletionServiceClient) CompletionStream(ctx context.Context, in *CompletionStreamRequest, opts ...grpc.CallOption) (CommandCompletionService_CompletionStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CommandCompletionService_serviceDesc.Streams[0], "/com.digitalasset.ledger.api.v1.CommandCompletionService/CompletionStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &commandCompletionServiceCompletionStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CommandCompletionService_CompletionStreamClient interface {
	Recv() (*CompletionStreamResponse, error)
	grpc.ClientStream
}

type commandCompletionServiceCompletionStreamClient struct {
	grpc.ClientStream
}

func (x *commandCompletionServiceCompletionStreamClient) Recv() (*CompletionStreamResponse, error) {
	m := new(CompletionStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *commandCompletionServiceClient) CompletionEnd(ctx context.Context, in *CompletionEndRequest, opts ...grpc.CallOption) (*CompletionEndResponse, error) {
	out := new(CompletionEndResponse)
	err := c.cc.Invoke(ctx, "/com.digitalasset.ledger.api.v1.CommandCompletionService/CompletionEnd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommandCompletionServiceServer is the server API for CommandCompletionService service.
type CommandCompletionServiceServer interface {
	// Subscribe to command completion events.
	CompletionStream(*CompletionStreamRequest, CommandCompletionService_CompletionStreamServer) error
	// Returns the offset after the latest completion.
	CompletionEnd(context.Context, *CompletionEndRequest) (*CompletionEndResponse, error)
}

// UnimplementedCommandCompletionServiceServer can be embedded to have forward compatible implementations.
type UnimplementedCommandCompletionServiceServer struct {
}

func (*UnimplementedCommandCompletionServiceServer) CompletionStream(req *CompletionStreamRequest, srv CommandCompletionService_CompletionStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method CompletionStream not implemented")
}
func (*UnimplementedCommandCompletionServiceServer) CompletionEnd(ctx context.Context, req *CompletionEndRequest) (*CompletionEndResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompletionEnd not implemented")
}

func RegisterCommandCompletionServiceServer(s *grpc.Server, srv CommandCompletionServiceServer) {
	s.RegisterService(&_CommandCompletionService_serviceDesc, srv)
}

func _CommandCompletionService_CompletionStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CompletionStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CommandCompletionServiceServer).CompletionStream(m, &commandCompletionServiceCompletionStreamServer{stream})
}

type CommandCompletionService_CompletionStreamServer interface {
	Send(*CompletionStreamResponse) error
	grpc.ServerStream
}

type commandCompletionServiceCompletionStreamServer struct {
	grpc.ServerStream
}

func (x *commandCompletionServiceCompletionStreamServer) Send(m *CompletionStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _CommandCompletionService_CompletionEnd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompletionEndRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandCompletionServiceServer).CompletionEnd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/com.digitalasset.ledger.api.v1.CommandCompletionService/CompletionEnd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandCompletionServiceServer).CompletionEnd(ctx, req.(*CompletionEndRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CommandCompletionService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "com.digitalasset.ledger.api.v1.CommandCompletionService",
	HandlerType: (*CommandCompletionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CompletionEnd",
			Handler:    _CommandCompletionService_CompletionEnd_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CompletionStream",
			Handler:       _CommandCompletionService_CompletionStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "com/digitalasset/ledger/api/v1/command_completion_service.proto",
}
