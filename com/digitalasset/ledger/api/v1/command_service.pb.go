// Code generated by protoc-gen-go. DO NOT EDIT.
// source: com/digitalasset/ledger/api/v1/command_service.proto

package com_digitalasset_ledger_api_v1

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protobuf "google/protobuf"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// These commands are atomic, and will become transactions.
type SubmitAndWaitRequest struct {
	// The commands to be submitted.
	// Required
	Commands *Commands `protobuf:"bytes,1,opt,name=commands,proto3" json:"commands,omitempty"`
	// Server side tracing will be registered as a child of the submitted context.
	// This field is a future extension point and is currently not supported.
	// Optional
	TraceContext         *TraceContext `protobuf:"bytes,1000,opt,name=trace_context,json=traceContext,proto3" json:"trace_context,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *SubmitAndWaitRequest) Reset()         { *m = SubmitAndWaitRequest{} }
func (m *SubmitAndWaitRequest) String() string { return proto.CompactTextString(m) }
func (*SubmitAndWaitRequest) ProtoMessage()    {}
func (*SubmitAndWaitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a365ddd9f9d353b2, []int{0}
}

func (m *SubmitAndWaitRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SubmitAndWaitRequest.Unmarshal(m, b)
}
func (m *SubmitAndWaitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SubmitAndWaitRequest.Marshal(b, m, deterministic)
}
func (m *SubmitAndWaitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubmitAndWaitRequest.Merge(m, src)
}
func (m *SubmitAndWaitRequest) XXX_Size() int {
	return xxx_messageInfo_SubmitAndWaitRequest.Size(m)
}
func (m *SubmitAndWaitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubmitAndWaitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubmitAndWaitRequest proto.InternalMessageInfo

func (m *SubmitAndWaitRequest) GetCommands() *Commands {
	if m != nil {
		return m.Commands
	}
	return nil
}

func (m *SubmitAndWaitRequest) GetTraceContext() *TraceContext {
	if m != nil {
		return m.TraceContext
	}
	return nil
}

type SubmitAndWaitForTransactionIdResponse struct {
	// The id of the transaction that resulted from the submitted command.
	// Required
	TransactionId        string   `protobuf:"bytes,1,opt,name=transaction_id,json=transactionId,proto3" json:"transaction_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubmitAndWaitForTransactionIdResponse) Reset()         { *m = SubmitAndWaitForTransactionIdResponse{} }
func (m *SubmitAndWaitForTransactionIdResponse) String() string { return proto.CompactTextString(m) }
func (*SubmitAndWaitForTransactionIdResponse) ProtoMessage()    {}
func (*SubmitAndWaitForTransactionIdResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a365ddd9f9d353b2, []int{1}
}

func (m *SubmitAndWaitForTransactionIdResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SubmitAndWaitForTransactionIdResponse.Unmarshal(m, b)
}
func (m *SubmitAndWaitForTransactionIdResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SubmitAndWaitForTransactionIdResponse.Marshal(b, m, deterministic)
}
func (m *SubmitAndWaitForTransactionIdResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubmitAndWaitForTransactionIdResponse.Merge(m, src)
}
func (m *SubmitAndWaitForTransactionIdResponse) XXX_Size() int {
	return xxx_messageInfo_SubmitAndWaitForTransactionIdResponse.Size(m)
}
func (m *SubmitAndWaitForTransactionIdResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SubmitAndWaitForTransactionIdResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SubmitAndWaitForTransactionIdResponse proto.InternalMessageInfo

func (m *SubmitAndWaitForTransactionIdResponse) GetTransactionId() string {
	if m != nil {
		return m.TransactionId
	}
	return ""
}

type SubmitAndWaitForTransactionResponse struct {
	// The flat transaction that resulted from the submitted command.
	// Required
	Transaction          *Transaction `protobuf:"bytes,1,opt,name=transaction,proto3" json:"transaction,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *SubmitAndWaitForTransactionResponse) Reset()         { *m = SubmitAndWaitForTransactionResponse{} }
func (m *SubmitAndWaitForTransactionResponse) String() string { return proto.CompactTextString(m) }
func (*SubmitAndWaitForTransactionResponse) ProtoMessage()    {}
func (*SubmitAndWaitForTransactionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a365ddd9f9d353b2, []int{2}
}

func (m *SubmitAndWaitForTransactionResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SubmitAndWaitForTransactionResponse.Unmarshal(m, b)
}
func (m *SubmitAndWaitForTransactionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SubmitAndWaitForTransactionResponse.Marshal(b, m, deterministic)
}
func (m *SubmitAndWaitForTransactionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubmitAndWaitForTransactionResponse.Merge(m, src)
}
func (m *SubmitAndWaitForTransactionResponse) XXX_Size() int {
	return xxx_messageInfo_SubmitAndWaitForTransactionResponse.Size(m)
}
func (m *SubmitAndWaitForTransactionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SubmitAndWaitForTransactionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SubmitAndWaitForTransactionResponse proto.InternalMessageInfo

func (m *SubmitAndWaitForTransactionResponse) GetTransaction() *Transaction {
	if m != nil {
		return m.Transaction
	}
	return nil
}

type SubmitAndWaitForTransactionTreeResponse struct {
	// The transaction tree that resulted from the submitted command.
	// Required
	Transaction          *TransactionTree `protobuf:"bytes,1,opt,name=transaction,proto3" json:"transaction,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SubmitAndWaitForTransactionTreeResponse) Reset() {
	*m = SubmitAndWaitForTransactionTreeResponse{}
}
func (m *SubmitAndWaitForTransactionTreeResponse) String() string { return proto.CompactTextString(m) }
func (*SubmitAndWaitForTransactionTreeResponse) ProtoMessage()    {}
func (*SubmitAndWaitForTransactionTreeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a365ddd9f9d353b2, []int{3}
}

func (m *SubmitAndWaitForTransactionTreeResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SubmitAndWaitForTransactionTreeResponse.Unmarshal(m, b)
}
func (m *SubmitAndWaitForTransactionTreeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SubmitAndWaitForTransactionTreeResponse.Marshal(b, m, deterministic)
}
func (m *SubmitAndWaitForTransactionTreeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubmitAndWaitForTransactionTreeResponse.Merge(m, src)
}
func (m *SubmitAndWaitForTransactionTreeResponse) XXX_Size() int {
	return xxx_messageInfo_SubmitAndWaitForTransactionTreeResponse.Size(m)
}
func (m *SubmitAndWaitForTransactionTreeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SubmitAndWaitForTransactionTreeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SubmitAndWaitForTransactionTreeResponse proto.InternalMessageInfo

func (m *SubmitAndWaitForTransactionTreeResponse) GetTransaction() *TransactionTree {
	if m != nil {
		return m.Transaction
	}
	return nil
}

func init() {
	proto.RegisterType((*SubmitAndWaitRequest)(nil), "com.digitalasset.ledger.api.v1.SubmitAndWaitRequest")
	proto.RegisterType((*SubmitAndWaitForTransactionIdResponse)(nil), "com.digitalasset.ledger.api.v1.SubmitAndWaitForTransactionIdResponse")
	proto.RegisterType((*SubmitAndWaitForTransactionResponse)(nil), "com.digitalasset.ledger.api.v1.SubmitAndWaitForTransactionResponse")
	proto.RegisterType((*SubmitAndWaitForTransactionTreeResponse)(nil), "com.digitalasset.ledger.api.v1.SubmitAndWaitForTransactionTreeResponse")
}

func init() {
	proto.RegisterFile("com/digitalasset/ledger/api/v1/command_service.proto", fileDescriptor_a365ddd9f9d353b2)
}

var fileDescriptor_a365ddd9f9d353b2 = []byte{
	// 424 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x94, 0xdd, 0x4a, 0xe3, 0x40,
	0x1c, 0xc5, 0x09, 0x2c, 0xfb, 0x31, 0xdd, 0xf6, 0x22, 0x2c, 0x4b, 0x69, 0xd9, 0x0f, 0xb2, 0x94,
	0x2d, 0xec, 0xee, 0xcc, 0xb6, 0xf6, 0xca, 0x3b, 0x1b, 0xab, 0x78, 0xa1, 0x62, 0x5a, 0xf0, 0x4a,
	0xca, 0x34, 0xf9, 0x1b, 0x06, 0x9a, 0x4c, 0xcc, 0x4c, 0x8a, 0x82, 0x0f, 0xe2, 0x85, 0x17, 0x3e,
	0x82, 0x0f, 0xe2, 0x83, 0xf8, 0x18, 0xd2, 0x24, 0x8d, 0x13, 0xa8, 0x49, 0x3f, 0x2e, 0x87, 0xfc,
	0x7f, 0xe7, 0x9c, 0xff, 0xcc, 0x21, 0xa8, 0x67, 0x73, 0x8f, 0x38, 0xcc, 0x65, 0x92, 0x4e, 0xa9,
	0x10, 0x20, 0xc9, 0x14, 0x1c, 0x17, 0x42, 0x42, 0x03, 0x46, 0x66, 0x1d, 0x62, 0x73, 0xcf, 0xa3,
	0xbe, 0x33, 0x16, 0x10, 0xce, 0x98, 0x0d, 0x38, 0x08, 0xb9, 0xe4, 0xfa, 0x77, 0x9b, 0x7b, 0x58,
	0xa5, 0x70, 0x42, 0x61, 0x1a, 0x30, 0x3c, 0xeb, 0x34, 0xfe, 0xad, 0xa6, 0x2a, 0x12, 0xb9, 0x46,
	0xb7, 0x64, 0x5c, 0x86, 0xd4, 0x86, 0xb1, 0xcd, 0x7d, 0x09, 0xd7, 0x32, 0x65, 0xfe, 0x97, 0x33,
	0xbe, 0xa0, 0xb6, 0x64, 0xdc, 0x4f, 0x89, 0xa6, 0xcb, 0xb9, 0x3b, 0x05, 0x12, 0x9f, 0x26, 0xd1,
	0x25, 0x01, 0x2f, 0x90, 0x37, 0xc9, 0x47, 0xe3, 0x51, 0x43, 0x5f, 0x86, 0xd1, 0xc4, 0x63, 0x72,
	0xcf, 0x77, 0xce, 0x29, 0x93, 0x16, 0x5c, 0x45, 0x20, 0xa4, 0xbe, 0x8f, 0x3e, 0x2e, 0xd2, 0xd6,
	0xb5, 0x9f, 0x5a, 0xbb, 0xd2, 0x6d, 0xe3, 0xe2, 0xed, 0xb1, 0x99, 0xce, 0x5b, 0x19, 0xa9, 0x5b,
	0xa8, 0x9a, 0x5b, 0xa2, 0xfe, 0xfc, 0x21, 0xd6, 0xfa, 0x5b, 0xa6, 0x35, 0x9a, 0x53, 0x66, 0x02,
	0x59, 0x9f, 0xa5, 0x72, 0x32, 0x4e, 0x50, 0x2b, 0x97, 0xf8, 0x80, 0x87, 0xa3, 0xd7, 0xa5, 0x8f,
	0x1c, 0x0b, 0x44, 0xc0, 0x7d, 0x01, 0x7a, 0x0b, 0xd5, 0x94, 0xdb, 0x18, 0x33, 0x27, 0x5e, 0xe4,
	0x93, 0x55, 0x95, 0xea, 0xb8, 0x21, 0xd1, 0xaf, 0x02, 0xbd, 0x4c, 0xed, 0x18, 0x55, 0x14, 0x2e,
	0xbd, 0x93, 0x3f, 0x2b, 0xec, 0x91, 0x29, 0xa9, 0xbc, 0x71, 0x8b, 0x7e, 0x17, 0xb8, 0x8e, 0x42,
	0x80, 0xcc, 0xf9, 0x6c, 0x99, 0x33, 0x59, 0xc3, 0x39, 0x56, 0x53, 0x35, 0xba, 0x4f, 0xef, 0x50,
	0x2d, 0x7d, 0xae, 0x61, 0xd2, 0x70, 0xfd, 0x02, 0x55, 0x73, 0x81, 0xf4, 0x5e, 0x99, 0xc3, 0xb2,
	0xde, 0x34, 0xbe, 0xe2, 0xa4, 0x6e, 0x78, 0x51, 0x37, 0x3c, 0x98, 0xd7, 0x4d, 0xbf, 0xd7, 0xd0,
	0xb7, 0xc2, 0x67, 0xdb, 0xd0, 0x6f, 0xb0, 0x16, 0xf5, 0x66, 0x57, 0xee, 0x34, 0xd4, 0x2c, 0x98,
	0xdc, 0x30, 0x9c, 0xb9, 0x45, 0xb8, 0x2c, 0xda, 0x83, 0x86, 0x7e, 0x94, 0x54, 0x65, 0xc3, 0x78,
	0x87, 0x5b, 0xc4, 0x53, 0x1b, 0xda, 0xdf, 0x45, 0x25, 0x7f, 0xc6, 0x7e, 0x3d, 0xdf, 0xb6, 0xd3,
	0x48, 0x42, 0x68, 0xce, 0x27, 0x27, 0xef, 0xe3, 0xa2, 0xec, 0xbc, 0x04, 0x00, 0x00, 0xff, 0xff,
	0x01, 0x2d, 0x80, 0x6b, 0x92, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CommandServiceClient is the client API for CommandService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CommandServiceClient interface {
	// Submits a single composite command and waits for its result.
	// Returns ``RESOURCE_EXHAUSTED`` if the number of in-flight commands reached the maximum (if a limit is configured).
	// Propagates the gRPC error of failed submissions including DAML interpretation errors.
	SubmitAndWait(ctx context.Context, in *SubmitAndWaitRequest, opts ...grpc.CallOption) (*protobuf.Empty, error)
	// Submits a single composite command, waits for its result, and returns the transaction id.
	// Returns ``RESOURCE_EXHAUSTED`` if the number of in-flight commands reached the maximum (if a limit is configured).
	// Propagates the gRPC error of failed submissions including DAML interpretation errors.
	SubmitAndWaitForTransactionId(ctx context.Context, in *SubmitAndWaitRequest, opts ...grpc.CallOption) (*SubmitAndWaitForTransactionIdResponse, error)
	// Submits a single composite command, waits for its result, and returns the transaction.
	// Returns ``RESOURCE_EXHAUSTED`` if the number of in-flight commands reached the maximum (if a limit is configured).
	// Propagates the gRPC error of failed submissions including DAML interpretation errors.
	SubmitAndWaitForTransaction(ctx context.Context, in *SubmitAndWaitRequest, opts ...grpc.CallOption) (*SubmitAndWaitForTransactionResponse, error)
	// Submits a single composite command, waits for its result, and returns the transaction tree.
	// Returns ``RESOURCE_EXHAUSTED`` if the number of in-flight commands reached the maximum (if a limit is configured).
	// Propagates the gRPC error of failed submissions including DAML interpretation errors.
	SubmitAndWaitForTransactionTree(ctx context.Context, in *SubmitAndWaitRequest, opts ...grpc.CallOption) (*SubmitAndWaitForTransactionTreeResponse, error)
}

type commandServiceClient struct {
	cc *grpc.ClientConn
}

func NewCommandServiceClient(cc *grpc.ClientConn) CommandServiceClient {
	return &commandServiceClient{cc}
}

func (c *commandServiceClient) SubmitAndWait(ctx context.Context, in *SubmitAndWaitRequest, opts ...grpc.CallOption) (*protobuf.Empty, error) {
	out := new(protobuf.Empty)
	err := c.cc.Invoke(ctx, "/com.digitalasset.ledger.api.v1.CommandService/SubmitAndWait", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) SubmitAndWaitForTransactionId(ctx context.Context, in *SubmitAndWaitRequest, opts ...grpc.CallOption) (*SubmitAndWaitForTransactionIdResponse, error) {
	out := new(SubmitAndWaitForTransactionIdResponse)
	err := c.cc.Invoke(ctx, "/com.digitalasset.ledger.api.v1.CommandService/SubmitAndWaitForTransactionId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) SubmitAndWaitForTransaction(ctx context.Context, in *SubmitAndWaitRequest, opts ...grpc.CallOption) (*SubmitAndWaitForTransactionResponse, error) {
	out := new(SubmitAndWaitForTransactionResponse)
	err := c.cc.Invoke(ctx, "/com.digitalasset.ledger.api.v1.CommandService/SubmitAndWaitForTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) SubmitAndWaitForTransactionTree(ctx context.Context, in *SubmitAndWaitRequest, opts ...grpc.CallOption) (*SubmitAndWaitForTransactionTreeResponse, error) {
	out := new(SubmitAndWaitForTransactionTreeResponse)
	err := c.cc.Invoke(ctx, "/com.digitalasset.ledger.api.v1.CommandService/SubmitAndWaitForTransactionTree", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommandServiceServer is the server API for CommandService service.
type CommandServiceServer interface {
	// Submits a single composite command and waits for its result.
	// Returns ``RESOURCE_EXHAUSTED`` if the number of in-flight commands reached the maximum (if a limit is configured).
	// Propagates the gRPC error of failed submissions including DAML interpretation errors.
	SubmitAndWait(context.Context, *SubmitAndWaitRequest) (*protobuf.Empty, error)
	// Submits a single composite command, waits for its result, and returns the transaction id.
	// Returns ``RESOURCE_EXHAUSTED`` if the number of in-flight commands reached the maximum (if a limit is configured).
	// Propagates the gRPC error of failed submissions including DAML interpretation errors.
	SubmitAndWaitForTransactionId(context.Context, *SubmitAndWaitRequest) (*SubmitAndWaitForTransactionIdResponse, error)
	// Submits a single composite command, waits for its result, and returns the transaction.
	// Returns ``RESOURCE_EXHAUSTED`` if the number of in-flight commands reached the maximum (if a limit is configured).
	// Propagates the gRPC error of failed submissions including DAML interpretation errors.
	SubmitAndWaitForTransaction(context.Context, *SubmitAndWaitRequest) (*SubmitAndWaitForTransactionResponse, error)
	// Submits a single composite command, waits for its result, and returns the transaction tree.
	// Returns ``RESOURCE_EXHAUSTED`` if the number of in-flight commands reached the maximum (if a limit is configured).
	// Propagates the gRPC error of failed submissions including DAML interpretation errors.
	SubmitAndWaitForTransactionTree(context.Context, *SubmitAndWaitRequest) (*SubmitAndWaitForTransactionTreeResponse, error)
}

// UnimplementedCommandServiceServer can be embedded to have forward compatible implementations.
type UnimplementedCommandServiceServer struct {
}

func (*UnimplementedCommandServiceServer) SubmitAndWait(ctx context.Context, req *SubmitAndWaitRequest) (*protobuf.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitAndWait not implemented")
}
func (*UnimplementedCommandServiceServer) SubmitAndWaitForTransactionId(ctx context.Context, req *SubmitAndWaitRequest) (*SubmitAndWaitForTransactionIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitAndWaitForTransactionId not implemented")
}
func (*UnimplementedCommandServiceServer) SubmitAndWaitForTransaction(ctx context.Context, req *SubmitAndWaitRequest) (*SubmitAndWaitForTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitAndWaitForTransaction not implemented")
}
func (*UnimplementedCommandServiceServer) SubmitAndWaitForTransactionTree(ctx context.Context, req *SubmitAndWaitRequest) (*SubmitAndWaitForTransactionTreeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitAndWaitForTransactionTree not implemented")
}

func RegisterCommandServiceServer(s *grpc.Server, srv CommandServiceServer) {
	s.RegisterService(&_CommandService_serviceDesc, srv)
}

func _CommandService_SubmitAndWait_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitAndWaitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).SubmitAndWait(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/com.digitalasset.ledger.api.v1.CommandService/SubmitAndWait",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).SubmitAndWait(ctx, req.(*SubmitAndWaitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_SubmitAndWaitForTransactionId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitAndWaitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).SubmitAndWaitForTransactionId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/com.digitalasset.ledger.api.v1.CommandService/SubmitAndWaitForTransactionId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).SubmitAndWaitForTransactionId(ctx, req.(*SubmitAndWaitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_SubmitAndWaitForTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitAndWaitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).SubmitAndWaitForTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/com.digitalasset.ledger.api.v1.CommandService/SubmitAndWaitForTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).SubmitAndWaitForTransaction(ctx, req.(*SubmitAndWaitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_SubmitAndWaitForTransactionTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitAndWaitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).SubmitAndWaitForTransactionTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/com.digitalasset.ledger.api.v1.CommandService/SubmitAndWaitForTransactionTree",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).SubmitAndWaitForTransactionTree(ctx, req.(*SubmitAndWaitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CommandService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "com.digitalasset.ledger.api.v1.CommandService",
	HandlerType: (*CommandServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubmitAndWait",
			Handler:    _CommandService_SubmitAndWait_Handler,
		},
		{
			MethodName: "SubmitAndWaitForTransactionId",
			Handler:    _CommandService_SubmitAndWaitForTransactionId_Handler,
		},
		{
			MethodName: "SubmitAndWaitForTransaction",
			Handler:    _CommandService_SubmitAndWaitForTransaction_Handler,
		},
		{
			MethodName: "SubmitAndWaitForTransactionTree",
			Handler:    _CommandService_SubmitAndWaitForTransactionTree_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "com/digitalasset/ledger/api/v1/command_service.proto",
}
