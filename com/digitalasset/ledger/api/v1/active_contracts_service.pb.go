// Code generated by protoc-gen-go. DO NOT EDIT.
// source: com/digitalasset/ledger/api/v1/active_contracts_service.proto

package com_digitalasset_ledger_api_v1

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type GetActiveContractsRequest struct {
	// Must correspond to the ledger ID reported by the Ledger Identification Service.
	// Required
	LedgerId string `protobuf:"bytes,1,opt,name=ledger_id,json=ledgerId,proto3" json:"ledger_id,omitempty"`
	// Templates to include in the served snapshot, per party.
	// Required
	Filter *TransactionFilter `protobuf:"bytes,2,opt,name=filter,proto3" json:"filter,omitempty"`
	// If enabled, values served over the API will contain more information than strictly necessary to interpret the data.
	// In particular, setting the verbose flag to true triggers the ledger to include labels for record fields.
	// Optional
	Verbose bool `protobuf:"varint,3,opt,name=verbose,proto3" json:"verbose,omitempty"`
	// Server side tracing will be registered as a child of the submitted context.
	// This field is a future extension point and is currently not supported.
	// Optional
	TraceContext         *TraceContext `protobuf:"bytes,1000,opt,name=trace_context,json=traceContext,proto3" json:"trace_context,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *GetActiveContractsRequest) Reset()         { *m = GetActiveContractsRequest{} }
func (m *GetActiveContractsRequest) String() string { return proto.CompactTextString(m) }
func (*GetActiveContractsRequest) ProtoMessage()    {}
func (*GetActiveContractsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac98df4eb6d59f2f, []int{0}
}

func (m *GetActiveContractsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetActiveContractsRequest.Unmarshal(m, b)
}
func (m *GetActiveContractsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetActiveContractsRequest.Marshal(b, m, deterministic)
}
func (m *GetActiveContractsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetActiveContractsRequest.Merge(m, src)
}
func (m *GetActiveContractsRequest) XXX_Size() int {
	return xxx_messageInfo_GetActiveContractsRequest.Size(m)
}
func (m *GetActiveContractsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetActiveContractsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetActiveContractsRequest proto.InternalMessageInfo

func (m *GetActiveContractsRequest) GetLedgerId() string {
	if m != nil {
		return m.LedgerId
	}
	return ""
}

func (m *GetActiveContractsRequest) GetFilter() *TransactionFilter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *GetActiveContractsRequest) GetVerbose() bool {
	if m != nil {
		return m.Verbose
	}
	return false
}

func (m *GetActiveContractsRequest) GetTraceContext() *TraceContext {
	if m != nil {
		return m.TraceContext
	}
	return nil
}

type GetActiveContractsResponse struct {
	// Included in the last message.
	// The client should start consuming the transactions endpoint with this offset.
	// The format of this field is described in ``ledger_offset.proto``.
	// Required
	Offset string `protobuf:"bytes,1,opt,name=offset,proto3" json:"offset,omitempty"`
	// The workflow that created the contracts.
	// Optional
	WorkflowId string `protobuf:"bytes,2,opt,name=workflow_id,json=workflowId,proto3" json:"workflow_id,omitempty"`
	// The list of contracts that were introduced by the workflow with ``workflow_id`` at the offset.
	// Optional
	ActiveContracts []*CreatedEvent `protobuf:"bytes,3,rep,name=active_contracts,json=activeContracts,proto3" json:"active_contracts,omitempty"`
	// Zipkin trace context.
	// This field is a future extension point and is currently not supported.
	// Optional
	TraceContext         *TraceContext `protobuf:"bytes,1000,opt,name=trace_context,json=traceContext,proto3" json:"trace_context,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *GetActiveContractsResponse) Reset()         { *m = GetActiveContractsResponse{} }
func (m *GetActiveContractsResponse) String() string { return proto.CompactTextString(m) }
func (*GetActiveContractsResponse) ProtoMessage()    {}
func (*GetActiveContractsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac98df4eb6d59f2f, []int{1}
}

func (m *GetActiveContractsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetActiveContractsResponse.Unmarshal(m, b)
}
func (m *GetActiveContractsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetActiveContractsResponse.Marshal(b, m, deterministic)
}
func (m *GetActiveContractsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetActiveContractsResponse.Merge(m, src)
}
func (m *GetActiveContractsResponse) XXX_Size() int {
	return xxx_messageInfo_GetActiveContractsResponse.Size(m)
}
func (m *GetActiveContractsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetActiveContractsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetActiveContractsResponse proto.InternalMessageInfo

func (m *GetActiveContractsResponse) GetOffset() string {
	if m != nil {
		return m.Offset
	}
	return ""
}

func (m *GetActiveContractsResponse) GetWorkflowId() string {
	if m != nil {
		return m.WorkflowId
	}
	return ""
}

func (m *GetActiveContractsResponse) GetActiveContracts() []*CreatedEvent {
	if m != nil {
		return m.ActiveContracts
	}
	return nil
}

func (m *GetActiveContractsResponse) GetTraceContext() *TraceContext {
	if m != nil {
		return m.TraceContext
	}
	return nil
}

func init() {
	proto.RegisterType((*GetActiveContractsRequest)(nil), "com.digitalasset.ledger.api.v1.GetActiveContractsRequest")
	proto.RegisterType((*GetActiveContractsResponse)(nil), "com.digitalasset.ledger.api.v1.GetActiveContractsResponse")
}

func init() {
	proto.RegisterFile("com/digitalasset/ledger/api/v1/active_contracts_service.proto", fileDescriptor_ac98df4eb6d59f2f)
}

var fileDescriptor_ac98df4eb6d59f2f = []byte{
	// 391 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x53, 0xcd, 0xaa, 0xd3, 0x40,
	0x14, 0x66, 0x5a, 0xe8, 0xcf, 0x54, 0x51, 0x66, 0x51, 0x62, 0x04, 0x0d, 0x5d, 0x15, 0x91, 0xc4,
	0xd6, 0x85, 0x28, 0xb8, 0xb0, 0x45, 0xa5, 0x2b, 0x21, 0x0a, 0x2e, 0xc3, 0x74, 0x72, 0x52, 0x06,
	0xd3, 0x4c, 0x9c, 0x39, 0x4d, 0xbb, 0x76, 0xef, 0x7b, 0xf8, 0x68, 0x6e, 0x7d, 0x03, 0x49, 0x26,
	0xe5, 0xb6, 0xbd, 0xbd, 0x37, 0xe5, 0xc2, 0x5d, 0x9e, 0x93, 0x7c, 0xe7, 0xfb, 0xc9, 0x17, 0xfa,
	0x5e, 0xa8, 0x75, 0x10, 0xcb, 0x95, 0x44, 0x9e, 0x72, 0x63, 0x00, 0x83, 0x14, 0xe2, 0x15, 0xe8,
	0x80, 0xe7, 0x32, 0x28, 0x26, 0x01, 0x17, 0x28, 0x0b, 0x88, 0x84, 0xca, 0x50, 0x73, 0x81, 0x26,
	0x32, 0xa0, 0x0b, 0x29, 0xc0, 0xcf, 0xb5, 0x42, 0xc5, 0x9e, 0x09, 0xb5, 0xf6, 0x0f, 0xe1, 0xbe,
	0x85, 0xfb, 0x3c, 0x97, 0x7e, 0x31, 0x71, 0x5f, 0x34, 0x9c, 0x87, 0x02, 0x32, 0xb4, 0xb7, 0xdc,
	0x37, 0x0d, 0xef, 0xa2, 0xe6, 0x99, 0x29, 0xf5, 0xa8, 0x2c, 0x4a, 0x64, 0x8a, 0xa0, 0x6b, 0xe0,
	0xb4, 0x19, 0x28, 0xac, 0x05, 0xd8, 0xd5, 0x64, 0xa3, 0x7f, 0x84, 0x3e, 0xf9, 0x0c, 0xf8, 0xa1,
	0xb2, 0x37, 0xdf, 0xbb, 0x0b, 0xe1, 0xe7, 0x06, 0x0c, 0xb2, 0xa7, 0xb4, 0x6f, 0x4f, 0x44, 0x32,
	0x76, 0x88, 0x47, 0xc6, 0xfd, 0xb0, 0x67, 0x17, 0x8b, 0x98, 0x2d, 0x68, 0xc7, 0xd2, 0x3b, 0x2d,
	0x8f, 0x8c, 0x07, 0xd3, 0x89, 0x7f, 0x7b, 0x08, 0xfe, 0xb7, 0x2b, 0xe1, 0x9f, 0x2a, 0x60, 0x58,
	0x1f, 0x60, 0x0e, 0xed, 0x16, 0xa0, 0x97, 0xca, 0x80, 0xd3, 0xf6, 0xc8, 0xb8, 0x17, 0xee, 0x47,
	0x16, 0xd2, 0x87, 0x47, 0xb2, 0x9d, 0xbf, 0xdd, 0x8a, 0xec, 0xe5, 0x05, 0x64, 0xa2, 0x32, 0x04,
	0x3b, 0x0c, 0x1f, 0xe0, 0xc1, 0x34, 0xfa, 0xd5, 0xa2, 0xee, 0x39, 0xcf, 0x26, 0x57, 0x99, 0x01,
	0x36, 0xa4, 0x1d, 0x95, 0x24, 0x06, 0xb0, 0x76, 0x5c, 0x4f, 0xec, 0x39, 0x1d, 0x6c, 0x95, 0xfe,
	0x91, 0xa4, 0x6a, 0x5b, 0xc6, 0xd1, 0xaa, 0x1e, 0xd2, 0xfd, 0x6a, 0x11, 0xb3, 0xef, 0xf4, 0xf1,
	0x69, 0x4d, 0x9c, 0xb6, 0xd7, 0xbe, 0x44, 0xed, 0x5c, 0x03, 0x47, 0x88, 0x3f, 0x96, 0x35, 0x08,
	0x1f, 0xf1, 0x63, 0x65, 0xf7, 0x11, 0xc2, 0xf4, 0x0f, 0xa1, 0xc3, 0x93, 0x04, 0xbe, 0xda, 0x4a,
	0xb3, 0xdf, 0x84, 0xb2, 0xeb, 0xf9, 0xb0, 0xb7, 0x4d, 0x6c, 0x37, 0xf6, 0xc8, 0x7d, 0x77, 0x17,
	0xa8, 0xfd, 0x1c, 0xaf, 0xc8, 0x6c, 0x46, 0x1b, 0x7e, 0xaf, 0x99, 0x77, 0xde, 0xc9, 0x97, 0x0d,
	0x82, 0x9e, 0x97, 0x88, 0x65, 0xa7, 0xaa, 0xfb, 0xeb, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0x1c,
	0xf4, 0x00, 0xf5, 0xe8, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ActiveContractsServiceClient is the client API for ActiveContractsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ActiveContractsServiceClient interface {
	// Returns a stream of the latest snapshot of active contracts. Getting an empty stream means that the active contracts set is empty and the client should listen to transactions using ``LEDGER_BEGIN``.
	// Clients SHOULD NOT assume that the set of active contracts they receive reflects the state at the ledger end.
	GetActiveContracts(ctx context.Context, in *GetActiveContractsRequest, opts ...grpc.CallOption) (ActiveContractsService_GetActiveContractsClient, error)
}

type activeContractsServiceClient struct {
	cc *grpc.ClientConn
}

func NewActiveContractsServiceClient(cc *grpc.ClientConn) ActiveContractsServiceClient {
	return &activeContractsServiceClient{cc}
}

func (c *activeContractsServiceClient) GetActiveContracts(ctx context.Context, in *GetActiveContractsRequest, opts ...grpc.CallOption) (ActiveContractsService_GetActiveContractsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ActiveContractsService_serviceDesc.Streams[0], "/com.digitalasset.ledger.api.v1.ActiveContractsService/GetActiveContracts", opts...)
	if err != nil {
		return nil, err
	}
	x := &activeContractsServiceGetActiveContractsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ActiveContractsService_GetActiveContractsClient interface {
	Recv() (*GetActiveContractsResponse, error)
	grpc.ClientStream
}

type activeContractsServiceGetActiveContractsClient struct {
	grpc.ClientStream
}

func (x *activeContractsServiceGetActiveContractsClient) Recv() (*GetActiveContractsResponse, error) {
	m := new(GetActiveContractsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ActiveContractsServiceServer is the server API for ActiveContractsService service.
type ActiveContractsServiceServer interface {
	// Returns a stream of the latest snapshot of active contracts. Getting an empty stream means that the active contracts set is empty and the client should listen to transactions using ``LEDGER_BEGIN``.
	// Clients SHOULD NOT assume that the set of active contracts they receive reflects the state at the ledger end.
	GetActiveContracts(*GetActiveContractsRequest, ActiveContractsService_GetActiveContractsServer) error
}

// UnimplementedActiveContractsServiceServer can be embedded to have forward compatible implementations.
type UnimplementedActiveContractsServiceServer struct {
}

func (*UnimplementedActiveContractsServiceServer) GetActiveContracts(req *GetActiveContractsRequest, srv ActiveContractsService_GetActiveContractsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetActiveContracts not implemented")
}

func RegisterActiveContractsServiceServer(s *grpc.Server, srv ActiveContractsServiceServer) {
	s.RegisterService(&_ActiveContractsService_serviceDesc, srv)
}

func _ActiveContractsService_GetActiveContracts_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetActiveContractsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ActiveContractsServiceServer).GetActiveContracts(m, &activeContractsServiceGetActiveContractsServer{stream})
}

type ActiveContractsService_GetActiveContractsServer interface {
	Send(*GetActiveContractsResponse) error
	grpc.ServerStream
}

type activeContractsServiceGetActiveContractsServer struct {
	grpc.ServerStream
}

func (x *activeContractsServiceGetActiveContractsServer) Send(m *GetActiveContractsResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _ActiveContractsService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "com.digitalasset.ledger.api.v1.ActiveContractsService",
	HandlerType: (*ActiveContractsServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetActiveContracts",
			Handler:       _ActiveContractsService_GetActiveContracts_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "com/digitalasset/ledger/api/v1/active_contracts_service.proto",
}
